<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Подробная памятка по Git</title>
<style>
    body { font-family: 'Arial', sans-serif; line-height: 1.6; margin: 40px; }
    h1 { color: navy; margin-bottom: 20px; }
    h2 { color: darkred; margin-top: 20px; }
    pre {
        background-color: #f4f4f4; 
        border-left: 3px solid navy; 
        padding: 10px; 
        font-family: monospace;
        overflow: auto; /* Добавляет полосы прокрутки, если текст не помещается */
        white-space: pre-wrap; /* Переносит строки, если они достигают конца контейнера */
        word-wrap: break-word; /* Переносит длинные слова на новую строку */
    }
    p { margin: 20px 0; }
</style>
</head>
<body>
<h1>Памятка по Git</h1>

<p>а это инструкция, написанная собственноручно мной, Дионисом Леонидовичем</p>

<h2>Часть 1</h2>
<p>На локалке</p>
<pre>
    часть 1
    на локалке
    
    создаем проект 
    далее инициализируем проект в git командой 
    git init 
    после этого в проект добавляется папка git 
    далее добавляем в индекс все новые файлы нового проекта 
    git add .
    и далее сохраняем в локальное хранилище командой
    git commit -m "вот такая петрушка"
    чтобы посмотреть все наши коммиты используем команду 
    git log
    или - для отображения коммитов одну строчку
    git log --oneline
    или для отображения ветвлений и слияний 
    git log --graph --decorate --oneline --all
    далее мы можем посмотреть весь проект в нужном коммите то есть на нужном сохранении, как в игре, вбив команду 
    git checkout 9894854 
    цифры 9894854 обозначают id коммита или нужного нам сохранения 
    то есть мы можем вернуться практически в любое время и проект будет до всех изменений, которые я внесу после указанного коммита - и это уже круче файловой системы и всех сохраняшек 
    если например я просматриваю старый коммит - где проект работал и мне нужно в эту версию версию внести какое-то изменение,
    то есть мы возвращаемся таким образом в состояние проекта, сохраненное на то время без учета дальнейших изменений в будущем. И далее изменяем что-либо в проекте в каком-либо из файлов или множестве файлов, например, в файле src/app.rs
    и далее добавляем все измененные файлы в индекс
    git add .
    либо конкретный файл из измененных
    git add src/app.rs
    и далее создаем коммит 
    git commit -m "описание изменений которые я произвел 16 марта в файле от 12 марта сего года"
    но важно понимать, что мы сейчас не находимся ни в одной из веток, что обозначает, что мы пребываем в состоянии detached HEAD
    если мы хотим чтобы сохраненный коммит стал в главной ветке main, 
    то существует 2 способа сделать это: 
    1 способ
    - вернуться в главную ветку main командой 
    git checkout main 
    и интегрировать коммит из detached HEAD (безветочное состояние) в главную ветку main командой 
    git cherry-pick 345456436546
    так можно вбить так 
    git merge 345456436546 - но лучше cherry-pick 
    где 345456436546 - это идентификатор сделанного нами коммита до этого, когда он находился в состоянии detached HEAD коммит с комментом "описание изменений которые я произвел 16 марта в файле от 12 марта сего года"
    посмотреть id коммита можно командой 
    git log
    чтобы посмотреть в какой ветке мы находимся
    git branch
    если мы хотим посмотреть события в текущей ветке то 
    git status 
    2 способ
    также помимо быстрого переноса только что созданного коммита,
    существует сохранение сначала из альтернативной ветки, которую мы создаем когда входим в коммит,
    где скажем проект работал, ну то есть чтобы создать новую ветку, вначале входим по id в нужный коммит командой
    git checkout change_commit 
    далее создаем новую ветку командой с параметром -b который эту ветку и создает 
    git checkout -b new-branch
    изменяем, если это необходимо, что-то в файлах 
    далее заносим в индекс 
    git add .
    и далее делаем коммит
    git commit -a -m "комментарий"
    и далее переходим в главную ветку main командой 
    git checkout main
    и далее производим слияние главной и только что созданной ветки командой
    git merge new-branch
    2 - отдельный случай второго способа - когда альтернативная ветка уже существует 
    если же ветка уже существует, то для начала нужно убедиться, что мы находимся в главной ветке командой 
    git branch 
    где в выводе будет звездочка такого вида * которая обозначает ветку, в которой мы находимся - если в главной, то едем дальше, 
    а если нет - то вбиваем команду 
    git checkout main 
    тем самым перемещаясь в главную папку 
    и далее, когда мы точно убедились, что мы находимся в главной папке, то производим слияние то есть перемещение альтернативной в главную ветку командой
    git merge past_branch
    где past_branch нужно заменить на реальное имя ветки 
    после этого произойдет слияние, которое в реальности будет выражено тем, что это слияние будет сохранено в новом коммите, который создается автоматически при команде слияния git merge branch_create например) 
    если после слияния мы захотим удалить альтернативную ветку то делается это командой 
    git branch -d change2604_2904
    где change2604_2904 это имя удаляемой ветки, а -d как я понял параметр удаления 
    если git сообщает перед удалением, что ветка не была полностью слита, и предотвращает удаление ветки, чтобы не потерялись данные, то мы можем удалить эту ветку принудительно командой с параметром удаления -D с заглавной буквы, я так понял, что заглавная буква любого параметра обозначает принудительность выполнения 
    git branch -D change2604_2904
    также если эта ветка была отправлена на github до ее удаления из локального хранилища, 
    то можно удалить ее из github командой 
    git push origin --delete name_branch\
    также мы можем не удаляя коммит отменить его действие командой 
    git revert id_commit
    после этого мы попадаем в междумирие, для выхода из которого нужно нажать ctrl + с и далее ввести команду 
    :qa
    для выхода из междумирия, которое отменило действия выбранного нами коммита - такая вот петрушка 
    и как только мы выйдем - действие отменится
    в общем 
    checkout позволяет посмотреть 
    revert позволяет отменить действие, но не удалять 
    git reset - сложная тема - почитатать можно под *1
    а если заиксперементировался и решил вернутся к последнему коммиту то команда 
    git reset id_commit 
    также эта команда когда перемещает указатель HEAD на этот коммент, отменяя, но не удаляя коммиты выше указанного коммита
    кстати, HEAD указатель при просмотре коммитов командой git log указывает на ту директорию, которая открыта сейчас
    и по этому указателю мы можем точно понимать где мы находимся в моменте 
    если мы хотим просто переместить стрелку HEAD на целевой коммит без удаления 
    !!!а также если мы хотим удалить все коммиты позднее выбранного то все это можно сотворить следующей командой 
    git reset --hard id_commit
    это удалит все что было позднее указанного коммита 
    то есть git checkout полезен для просмотра проекта в выбранном коммите, анализе, тестировании старых версий,
    но без внесения изменений - потому что мы не можем случайно тут удалить коммит и так далее 
    git reset id_commit команда используется для изменения текущей ветки, перемещая HEAD  и текущий указатель текущей ветки назад на более ранний коммит
    также у reset есть опции --soft --mixed 
    опция --soft перемещает стрелочку HEAD к указанному коммиту, но оставляет рабочую директорию и индекс без изменений 
    get reset --soft id_commit
    </pre>

<br>

<p>часть 1а</p>

<h2>уточнения по теме опции команды git reset</h2>
<p>коротко говоря</p>
<pre>
    подытоживая, 
    команда git reset предлагает несколько опций, которые влияют на то, как именно будут изменяться индекс (staging area)
    и рабочая директория в зависимости от опции, которая применяется к git reset 
    1.
    опция --hard говорит сама за себя и, возвращая нас к выбранному коммиту, удаляет все что было после него  
    git reset --hard id_commit
    также есть вариация на тему опции --hard но смысл в том, что она отменяет последний коммит в зависимости от цифры после HEAD~ следующим образом 
    git reset --hard HEAD~1
    где цифра после HEAD~ обозначает количество коммитов, на которые нам нужно спуститься вниз на определенный коммит
    и все это количество коммитов, которое мы указываем в цифре удаляется, а мы перемещаемся на коммит ниже на столько,
    сколько было удалено коммитов, также git reset --hard удаляет все изменения в рабочей директории и индексе удаляемых
    коммитов, то есть подчистую 
    2.
    опция --soft выполняет функцию перемещения к выбранному коммиту, но оставляет рабочую директорию и индекс, 
    то есть В КОДЕ мы откатываемся назад на коммит, но при этом остаются все папки в рабочей директории и индексе,
    чтобы впоследствии мы могли их использовать на старом коммите, изменяя код и используя новые не удаленные инструменты
    и далее с новыми инструментами и внесенными изменениями в код можно сохранить новый коммит, 
    который возьмет лучшее из двух миров или времен)
    также можно написать так 
    git reset --hard HEAD~2
    что откатит нас на 2 коммита обратно, но при этом оставить рабочую директорию и индекс неприкосновенными
    3.
    опция --mixed 
    собственно, это опция по умолчанию для git reset, то есть не прописав вообще ни одной опции после git reset 
    эта опция прописывается по умолчанию и выполняет функцию этой опции, разумется, а заключается она в том, что
    она перемещает указатель HEAD к указанному коммиту и обновляет индекс, чтобы он соответствовал этому коммиту,
    оставляет рабочую директорию без изменений, 
    другими словами, все изменения после выбранного коммта с опцией --mixed останутся в рабочей директории, но будут неотслеживаемые, ну и по аналогии 
    git reset --mixed HEAD~1
    или конкретный коммит 
    git reset id_commit 
    
    коротко говоря 
    git reset --hard id_commit удаляет все подчистую до выбранного коммита 
    git reset --soft id_commit выполняет роль перемещения в выбранный коммит, оставляя рабочую директорию и индекс без изменений
    git reset --mixed id_commit опция --mixed перемещает HEAD к указанному коммиту, обновляя индекс, но оставляя рабочую директорию неизменной. И также опция --mixed идет с git reset по умолчанию 
    ну и далее если смотрим через git status список измененных файл файлов в ожидании перед индексом 
    и следующим шагом будет выборочное добавление в индекс все той же командой 
    git add name_file_from_workspace 
    где name_file_from_workspace имя определенного файла, который мы хотим добавить в том коммите, на который мы откатились командой git reset --mixed id_commit
    добавленных файлов из рабочей области предыдущего коммита может быть сколько угодно 
    git add file.rs app.rs git.html
    также после добавления новых файлов в индекс мы можем использовать команду 
    git diff --cached 
    эта команда покажет различия между индексом последнего коммита и текущего состояния индекса после добавление и вообще
    после добавления нужных изменений в индекс из рабочей директории от предыдущего коммита мы можем создать новый коммит все той же старой доброй командой создания коммита 
    git commit -m "изменения"
    также можно сделать отмену изменений в рабочей директории из предыдущего коммита, 
    другими словами, можем просто удалить не нужные файлы из этой директории командой 
    git restore file.js
    а удалить все файлы из рабочей директории можно командой 
    git restore .
    </pre>

    <p>при проблемах связанных с заливанием на удаленный сервер командой git push нужно синхронизировать локальное хранилище и удаленный репозиторий командой git pull далее инструкция</p>

    <pre>
        Используйте git pull для синхронизации с удаленным репозиторием:
bash
Copy code
git pull origin main
Если при этом возникнут конфликты, их нужно будет разрешить вручную. Отредактируйте файлы с конфликтами, затем добавьте их в индекс и завершите слияние:
bash
Copy code
git add .
git commit -m "Разрешение конфликтов после pull"
После успешного слияния и разрешения всех конфликтов, попробуйте снова отправить ваш коммит на сервер:
bash
Copy code
git push origin main
    </pre>

<h2>Часть 2</h2>
<p>перенос в удаленный репозиторий</p>
<pre>
    Github - чтобы загрузить локальный проект на github нужно (есть, кстати, другие репозитории, такие как GitLab или Bitbucket):
    нужно связать наш локальный проект с удаленным репозиторием командой 
    git remote add origin web_address_repo
    где web_address_repo - это адрес, который предоставляется после создания репозитория на github gitlab и Bitbucket 
    далее после того как мы вносим коммит в локальное хранилище,
    то мы можем отправить изменения в удаленный репозиторий командой
    git push -u origin main
    -u параметр фундаментально важен, потому что выполняет функцию отслеживания чего угодно,
    например, конкретной ветки, которую, разумеется, нужно создать (2. git checkout -b name_branche) до этого после захода в лог определенного коммита (1. git checkout number_commit) 
    и чтобы поставить в отслеживание определенную ветку, нужно ее прописать  
    git push -u origin branche_name
    после чего будет сохраняться как главная main ветка, так и выбранная и достатоточно просто вбить 
    git push
    и все изменения всех внесенных через параметр -u веток внесутся на Github 
    нюансы:
    также можно настроить git на отправку всех веток командой 
    git push --all origin
    этой командой мы отправляем все ветки на github принудительно даже без проставления отслеживания и изменения конфига
    кстати, в конфиге можно также прописать автоматическую отправку всех веток командой 
    git config --global push.default matching
    то есть прописав эту команду и изменив конфиг при команде 
    git push
    будут отправляться все ветки вне зависимости от отслеживания 
    по сути git push --all origin это принудительная отправка всех веток, но одноразовая, 
    но если мы пропишем в конфиге отправку всех веток git config --global push.default matching то все ветки будут сохраняться на постоянной основе командой git push просто
    чтобы всегда отправлять все на github можно это сделать принудительно 
    git push -u origin main --force    
</pre>


<h2>Часть 2а Разница между cherry-pick и merge</h2>
<p>ответ альберта:</p>
<pre>
    Команда git cherry-pick и операция слияния (git merge) в Git предназначены для разных сценариев работы с изменениями из различных веток.

    Отличия git cherry-pick от git merge:
    git cherry-pick:
    Цель: Эта команда позволяет выборочно применить один или несколько коммитов из другой ветки к текущей ветке. Это полезно, когда вам нужно включить определенные изменения, не объединяя всю ветку.
    Процесс: Вы выбираете конкретный коммит по его идентификатору и "выщипываете" его изменения для добавления в вашу текущую ветку. Это создает новый коммит в вашей ветке с теми же изменениями, что и в оригинальном коммите.
    Использование: Применяется, когда нужно избежать переноса всех изменений из целевой ветки, а нужно только конкретное изменение.
    git merge:
    Цель: Слияние используется для объединения изменений из одной ветки в другую. Это включает в себя все коммиты, которые были сделаны в одной ветке, и объединяет их с другой веткой.
    Процесс: Когда вы выполняете слияние, Git пытается автоматически объединить изменения из двух веток. Если возникают конфликты (изменения в одних и тех же частях файла в обеих ветках), Git потребует от вас их разрешения перед завершением слияния.
    Использование: Применяется для интеграции всех изменений из одной ветки в другую, особенно при завершении работы над фичей или при необходимости обновления ветки разработки последними изменениями из главной ветки (main/master).
    Пример использования git cherry-pick:
    bash
    Copy code
    git cherry-pick c3f4e55  # Применяет изменения из коммита с хэшем c3f4e55 к текущей ветке
    Пример использования git merge:
    bash
    Copy code
    git merge feature-branch  # Сливает все изменения из ветки feature-branch в текущую ветку
    Таким образом, выбор между cherry-pick и merge зависит от того, нужно ли вам принести из другой ветки конкретные изменения или целый ряд коммитов. 
</pre>

<h2>Часть 3 подытоживаение всего материала с добавлением дополнительных фишек от ИИ</h2>
<p>Ух</p>
<pre>
    Часть 1: На локалке
    Основные команды для начала работы и управления версиями:
    
    git init: Инициирует новый Git репозиторий. Это первый шаг в управлении версиями для вашего проекта.
    git add .: Добавляет все новые и изменённые файлы в индекс (staging area), подготавливая их к коммиту. Это способ выборочно добавлять изменения, которые вы хотите зафиксировать.
    git commit -m "Initial commit": Создает коммит, который сохраняет снимок текущего состояния индекса как постоянную запись в истории репозитория.
    Просмотр и навигация по истории изменений:
    
    git log --oneline --graph --decorate --all: Показывает историю коммитов с визуализацией ветвлений.
    --oneline упрощает вывод, показывая каждый коммит в одной строке.
    --graph отображает дерево ветвлений в текстовом виде.
    --decorate добавляет метки веток и тегов к коммитам.
    --all показывает все ветки в репозитории.
    git checkout 9894854: Переключается на коммит или ветку, позволяя вам видеть код в том состоянии, в котором он был на момент этого коммита.
    Управление ветками и изменениями:
    
    git checkout -b new-feature: Создаёт новую ветку и переключается на неё, позволяя начать работу над новыми функциями без влияния на основной код.
    git cherry-pick 345456436546: Применяет конкретный коммит к текущей ветке, полезно для переноса исправлений из одной ветки в другую.
    git merge feature-branch: Сливает изменения из указанной ветки в текущую. При наличии конфликтов необходимо их вручную разрешить, после чего сделать коммит слияния.
    Удаление веток:
    
    git branch -d old-branch: Удаляет ветку, если все её изменения уже включены в текущую ветку (слияние выполнено).
    git branch -D old-branch: Принудительно удаляет ветку, даже если в ней есть неслившиеся изменения. Используйте с осторожностью, чтобы не потерять работу.
    Часть 2: Работа с удалёнными репозиториями
    Как связать локальный проект с удалённым репозиторием и отправить изменения:
    
    git remote add origin https://github.com/username/repository.git: Добавляет ссылку на удалённый репозиторий, называемый "origin".
    git push -u origin main: Отправляет локальные изменения в ветку main удалённого репозитория и устанавливает отслеживание, что позволяет в дальнейшем использовать git push и git pull без указания дополнительных параметров.
    git pull origin main: Извлекает и сливает изменения из удалённого репозитория в текущую ветку, помогая держать вашу работу актуальной.
    Удаление удалённых веток:
    
    git push origin --delete old-branch: Удаляет ветку из удалённого репозитория, полезно для очистки старых или неиспользуемых веток.
    Дополнительные сведения и лучшие практики Git
    Продвинутое использование команды git reset:
    
    git reset --soft 345456436546: Откатывает индекс до указанного коммита, оставляя рабочую директорию без изменений, что полезно для пересоздания коммита или изменения его сообщения.
    git reset --mixed 345456436546: Сбрасывает индекс, но оставляет рабочую директорию неизменной, это поведение по умолчанию.
    git reset --hard 345456436546: Откатывает индекс и рабочую директорию, удаляя все изменения до указанного коммита, что полезно для отмены всех изменений и возвращения к стабильному состоянию.
    Восстановление после ошибок:
    
    git reflog: Отображает журнал всех действий в репозитории, позволяя вернуться к предыдущим состояниям даже после кажущейся потери данных.
    git revert 345456436546: Создаёт новый коммит, который отменяет изменения, внесённые указанным коммитом, без удаления истории.
    Продолжайте читать следующее сообщение для дополнения информации.
    
    git tag v1.0.0 345456436546: Создает тег для коммита. Теги часто используются для маркировки релизов или значимых этапов проекта.
    git checkout v1.0.0: Переключается на состояние кода, отмеченное тегом, удобно для возвращения к стабильным версиям.
    git push --tags: Отправляет теги в удалённый репозиторий, обеспечивая их доступность для других разработчиков.
    Продвинутое ветвление и слияние:
    
    git merge --no-ff feature-branch: Выполняет слияние с созданием коммита слияния, даже если возможно "быстрое слияние" (fast-forward). Это помогает сохранять историю изменений более структурированной.
    git rebase master: Переносит изменения текущей ветки на последние в master, полезно для поддержания чистой и последовательной истории изменений.
    Советы и хитрости
    Откат изменений:
    
    git checkout -- file.txt: Отменяет изменения в файле, возвращая его к последней версии в коммите.
    git stash: Временно сохраняет все изменения в текущей директории, позволяя переключиться на другую ветку без потери текущей работы.
    git stash pop: Применяет сохраненные изменения обратно в рабочую директорию после завершения работы в других ветках.
    Работа с конфигурацией Git:
    
    git config --global user.name "Your Name": Устанавливает ваше имя, используемое в коммитах.
    git config --global user.email "your@email.com": Устанавливает ваш email, также используется в истории коммитов.
    git config --list: Показывает текущие настройки Git.
    Это обширная картина использования Git, от основных команд до продвинутых техник управления историей и изменениями в вашем проекте. Git — мощный инструмент для управления версиями, который предлагает гибкость в управлении сложными проектами и помогает в работе как индивидуальных разработчиков, так и больших команд.</pre>


</body>
</html>

