<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Подробная памятка по Git</title>
<style>
    body { font-family: 'Arial', sans-serif; line-height: 1.6; margin: 40px; }
    h1 { color: navy; margin-bottom: 20px; }
    h2 { color: darkred; margin-top: 20px; }
    pre { background-color: #f4f4f4; border-left: 3px solid navy; padding: 10px; font-family: monospace; }
    p { margin: 20px 0; }
</style>
</head>
<body>
<h1>Памятка по Git</h1>

<h2>Часть 1: Локальная работа с Git</h2>
<p>Основные команды для начала работы и управления изменениями:</p>
<pre>
git init  # Инициирует новый Git репозиторий
git add .  # Добавляет все новые и изменённые файлы в индекс
git commit -m "Initial commit"  # Создаёт коммит с заданным сообщением
</pre>

<p>Для просмотра истории изменений и навигации по коммитам:</p>
<pre>
git log --oneline --graph --decorate --all  # Показывает историю коммитов с визуализацией ветвлений
git checkout 9894854  # Переключение на определённый коммит по его ID
</pre>

<p>Как управлять ветками и изменениями:</p>
<pre>
git checkout -b new-feature  # Создаёт и переключается на новую ветку
git cherry-pick 345456436546  # Применяет конкретный коммит к текущей ветке
git merge feature-branch  # Сливает изменения из указанной ветки в текущую
</pre>

<p>Удаление веток:</p>
<pre>
git branch -d old-branch  # Удаляет ветку, если она была слита
git branch -D old-branch  # Принудительно удаляет ветку
</pre>

<h2>Часть 2: Работа с удалёнными репозиториями</h2>
<p>Как связать локальный проект с удалённым репозиторием и отправить изменения:</p>
<pre>
git remote add origin https://github.com/username/repository.git  # Добавляет удалённый репозиторий
git push -u origin main  # Отправляет изменения в ветку main и устанавливает отслеживание
git pull origin main  # Извлекает и сливает изменения из ветки main удалённого репозитория
</pre>

<p>Удаление удалённых веток:</p>
<pre>
git push origin --delete old-branch  # Удаляет ветку из удалённого репозитория
</pre>

<h2>Дополнительные сведения и лучшие практики Git</h2>
<p>Важные советы и функции для эффективного использования Git:</p>
<pre>
git status  # Показывает статус изменений файлов в текущей ветке
git log --follow [file]  # Отслеживает историю изменений конкретного файла
git diff [branch1] [branch2]  # Показывает различия между двумя ветками
git stash  # Временно сохраняет изменения, позволяя переключиться на другую ветку
git rebase [branch]  # Переносит или объединяет последовательность коммитов в новую базу
</pre>

<h2>Работа с резервными ветками и восстановление</h2>
<p>Создание резервных веток и восстановление удалённых коммитов:</p>
<pre>
git branch backup-branch  # Создает резервную копию текущей ветки
git reflog  # Просмотр истории действий в репозитории, включая удаленные коммиты
git checkout -b recovery-branch [commit-hash]  # Создает новую ветку, начиная с определенного коммита
</pre>

<p>Эти команды помогают управлять критическими ситуациями, такими как случайное удаление важных веток или коммитов, позволяя вам восстанавливать необходимые данные из истории действий репозитория.</p>

<h2>Продвинутое ветвление и стратегии слияния</h2>
<p>Использование продвинутых стратегий ветвления и слияния для улучшения рабочего процесса:</p>
<pre>
git merge --no-ff feature-branch  # Выполняет слияние с созданием коммита слияния даже если возможно быстрое слияние
git rebase master  # Перебазирует текущую ветку на последние изменения в master для более чистой истории
</pre>

<p>Эти команды позволяют более гибко управлять историей проекта и поддерживать её чистоту и логичность, что важно для крупных командных проектов.</p>

<h2>Работа с тегами и релизами</h2>
<p>Управление релизами и маркировка важных точек в истории проекта:</p>
<pre>
git tag v1.0.0 345456436546  # Создает тег для коммита, обычно используется для обозначения релизов
git checkout v1.0.0  # Переключение на состояние кода, отмеченное тегом
git push --tags  # Отправляет теги в удалённый репозиторий
</pre>

<p>Теги в Git используются для маркировки важных этапов, таких как релизы или версии, облегчая навигацию по истории и управление версиями.</p>

<p>Каждый из этих разделов добавляет значительную глубину вашему пониманию Git, расширяя базовые операции до уровня, который может оказаться необходимым в сложных проектах или при работе в больших командах.</p>

<p>а это инструкция, написанная собственноручно мной, Дионисом Леонидовичем</p>

<h2>Часть 1</h2>
<p>На локалке</p>
<pre>
    создаем проект 
    далее инициализируем проект в git командой 
    git init 
    после этого в проект добавляется папка git 
    далее добавляем в индекс все новые файлы нового проекта 
    git add .
    и далее сохраняем в локальное хранилище командой
    git commit -m "вот такая петрушка"
    чтобы посмотреть все наши коммиты используем команду 
    git log
    или - для отображения коммитов одну строчку
    git log --oneline
    или для отображения ветвлений и слияний 
    git log --graph --decorate --oneline --all
    далее мы можем посмотреть весь проект в нужном коммите то есть на нужном сохранении, как в игре, вбив команду 
    git checkout 9894854 
    цифры 9894854 обозначают id коммита или нужного нам сохранения 
    то есть мы можем вернуться практически в любое время и проект будет до всех изменений, которые я внесу после указанного коммита - и это уже круче файловой системы и всех сохраняшек 
    если например я просматриваю старый коммит - где проект работал и мне нужно в эту версию версию внести какое-то изменение,
    то есть мы возвращаемся таким образом в состояние проекта, сохраненное на то время без учета дальнейших изменений в будущем. И далее изменяем что-либо в проекте в каком-либо из файлов или множестве файлов, например, в файле src/app.rs
    и далее добавляем все измененные файлы в индекс
    git add .
    либо конкретный файл из измененных
    git add src/app.rs
    и далее создаем коммит 
    git commit -m "описание изменений которые я произвел 16 марта в файле от 12 марта сего года"
    но важно понимать, что мы сейчас не находимся ни в одной из веток, что обозначает мы пребываем в состоянии detached HEAD
    если мы хотим чтобы сохраненный коммит стал в главной ветке main, 
    то существует 2 способа сделать это: 
    1 способ
    - вернуться в главную ветку main командой 
    git checkout main 
    и интегрировать коммит из detached HEAD (безветочное состояние) в главную ветку main командой 
    git cherry-pick 345456436546
    так можно вбить так 
    git merge 345456436546 - но лучше cherry-pick 
    где 345456436546 - это идентификатор сделанного нами коммита до этого, когда он находился в состоянии detached HEAD коммит с комментом "описание изменений которые я произвел 16 марта в файле от 12 марта сего года"
    посмотреть id коммита можно командой 
    git log
    чтобы посмотреть в какой ветке мы находимся
    git branch
    если мы хотим посмотреть события в текущей ветке то 
    git status 
    2 способ
    также помимо быстрого переноса только что созданного коммита,
    существует сохранение сначала из альтернативной ветки, которую мы создаем когда входим в коммит,
    где скажем проект работал, ну то есть чтобы создать новую ветку, вначале входим по id в нужный коммит командой
    git checkout change_commit 
    далее создаем новую ветку командой с параметром -b который эту ветку и создает 
    git checkout -b new-branch
    изменяем, если это необходимо, что-то в файлах и далее делаем коммит с авто внесением в индекс всех изменений при помощи параметра -a в команде
    git commit -a -m "комментарий"
    и далее переходим в главную ветку main командой 
    git checkout main
    и далее производим слияние главной и только что созданной ветки командой
    git merge new-branch
    2 - отдельный случай второго способа - когда альтернативная ветка уже существует 
    если же ветка уже существует, то для начала нужно убедиться, что мы находимся в главной ветке командой 
    git branch 
    где в выводе будет звездочка такого вида * которая обозначает ветку, в которой мы находимся - если в главной, то едем дальше, 
    а если нет - то вбиваем команду git checkout main тем самым перемещаясь в главную папку 
    и далее, когда мы точно убедились, что мы находимся в главной папке, то производим слияние то есть перемещение альтернативной в главную ветку командой
    git merge past_branch
    где past_branch нужно заменить на реальное имя ветки 
    после этого произойдет слияние, которое в реальности будет выражено тем, что это слияние будет сохранено в новом коммите, который создается автоматически при команде слияния git merge branch_create например) 
    если после слияния мы захотим удалить альтернативную ветку то делается это командой 
    git branch -d change2604_2904
    где change2604_2904 это имя удаляемой ветки, а -d как я понял параметр удаления 
    если git сообщает перед удалением, что ветка не была полностью слита, и предотвращает удаление ветки, чтобы не потерялись данные, 
    то мы можем удалить эту ветку принудительно командой с параметром удаления -D с заглавной буквы, я так понял, 
    что заглавная буква любого параметра обозначает принудительность выполнения 
    git branch -D change2604_2904
    также если эта ветка была отправлена на github до ее удаления из локального хранилища, 
    то можно удалить ее из github командой 
    git push origin --delete change2604_2904
    Эта команда отправит команду на удаление ветки change2604_2904 из удалённого репозитория origin    
</pre>

<br>

<h2>Часть 2</h2>
<p>перенос в удаленный репозиторий</p>
<pre>
    Github - чтобы загрузить локальный проект на github нужно (есть, кстати, другие репозитории, такие как GitLab или Bitbucket):
    нужно связать наш локальный проект с удаленным репозиторием командой 
    git remote add origin web_address_repo
    где web_address_repo - это адрес, который предоставляется после создания репозитория на github gitlab и Bitbucket 
    далее после того как мы вносим коммит в локальное хранилище,
    то мы можем отправить изменения в удаленный репозиторий командой
    git push -u origin main
    -u параметр фундаментально важен, потому что выполняет функцию отслеживания чего угодно,
    например, конкретной ветки, которую, разумеется, нужно создать (2. git checkout -b name_branche) до этого после захода в лог определенного коммита (1. git checkout number_commit) 
    и чтобы поставить в отслеживание определенную ветку, нужно ее прописать  
    git push -u origin branche_name
    после чего будет сохраняться как главная main ветка, так и выбранная и достатоточно просто вбить 
    git push
    и все изменения всех внесенных через параметр -u веток внесутся на Github 
    нюансы:
    также можно настроить git на отправку всех веток командой 
    git push --all origin
    этой командой мы отправляем все ветки на github принудительно даже без проставления отслеживания и изменения конфига
    кстати, в конфиге можно также прописать автоматическую отправку всех веток командой 
    git config --global push.default matching
    то есть прописав эту команду и изменив конфиг при команде 
    git push
    будут отправляться все ветки вне зависимости от отслеживания 
    по сути git push --all origin это принудительная отправка всех веток, но одноразовая, 
    но если мы пропишем в конфиге отправку всех веток git config --global push.default matching то все ветки будут сохраняться на постоянной основе командой git push просто
    чтобы всегда отправлять все на github можно это сделать принудительно 
    git push -u origin main --force    
</pre>


<h2>Разница между cherry-pick и merge</h2>
<p>ответ альберта:</p>
<pre>
    Команда git cherry-pick и операция слияния (git merge) в Git предназначены для разных сценариев работы с изменениями из различных веток.

    Отличия git cherry-pick от git merge:
    git cherry-pick:
    Цель: Эта команда позволяет выборочно применить один или несколько коммитов из другой ветки к текущей ветке. Это полезно, когда вам нужно включить определенные изменения, не объединяя всю ветку.
    Процесс: Вы выбираете конкретный коммит по его идентификатору и "выщипываете" его изменения для добавления в вашу текущую ветку. Это создает новый коммит в вашей ветке с теми же изменениями, что и в оригинальном коммите.
    Использование: Применяется, когда нужно избежать переноса всех изменений из целевой ветки, а нужно только конкретное изменение.
    git merge:
    Цель: Слияние используется для объединения изменений из одной ветки в другую. Это включает в себя все коммиты, которые были сделаны в одной ветке, и объединяет их с другой веткой.
    Процесс: Когда вы выполняете слияние, Git пытается автоматически объединить изменения из двух веток. Если возникают конфликты (изменения в одних и тех же частях файла в обеих ветках), Git потребует от вас их разрешения перед завершением слияния.
    Использование: Применяется для интеграции всех изменений из одной ветки в другую, особенно при завершении работы над фичей или при необходимости обновления ветки разработки последними изменениями из главной ветки (main/master).
    Пример использования git cherry-pick:
    bash
    Copy code
    git cherry-pick c3f4e55  # Применяет изменения из коммита с хэшем c3f4e55 к текущей ветке
    Пример использования git merge:
    bash
    Copy code
    git merge feature-branch  # Сливает все изменения из ветки feature-branch в текущую ветку
    Таким образом, выбор между cherry-pick и merge зависит от того, нужно ли вам принести из другой ветки конкретные изменения или целый ряд коммитов. 
</pre>




</body>
</html>

